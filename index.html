<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Tree</title>
    <style>
        /* Á∫ØÈªëËÉåÊôØ */
        html, body { 
            margin: 0; overflow: hidden; 
            background-color: #000000 !important; 
            height: 100%; font-family: 'Segoe UI', sans-serif; 
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* ÈöêËóèÊëÑÂÉèÂ§¥ÂéüÂßãÁîªÈù¢ÔºåÊàë‰ª¨Âè™ÈúÄË¶ÅÊï∞ÊçÆ */
        #input-video { position: absolute; top: 0; left: 0; opacity: 0; z-index: -1; width: 320px; height: 240px; pointer-events: none;}
        
        /* ÊëÑÂÉèÂ§¥ÂèçÈ¶àÈ¢ÑËßà (Âè≥‰∏äËßíÂ∞èÁ™óÂè£) */
        #camera-preview {
            position: absolute; bottom: 20px; left: 20px; z-index: 20;
            width: 160px; height: 120px; border-radius: 10px;
            border: 2px solid #FFE6A6; opacity: 0.7; transform: scaleX(-1); /* ÈïúÂÉè */
        }

        /* ÊâãÂäøÂÖâÊ†á */
        #hand-cursor {
            position: absolute; width: 40px; height: 40px; 
            border: 2px solid #FFD700; border-radius: 50%; 
            transform: translate(-50%, -50%); pointer-events: none; z-index: 100;
            display: none; box-shadow: 0 0 10px #FFD700;
            transition: width 0.2s, height 0.2s, background-color 0.2s;
        }
        #hand-cursor.pinching {
            width: 20px; height: 20px; background-color: #FFD700;
        }

        /* UI colors - Goose Yellow */
        #ui-layer {
            position: absolute; z-index: 10; width: 100%; height: 100%; pointer-events: none;
            display: flex; justify-content: flex-end; padding: 30px; box-sizing: border-box;
        }
        .sidebar-container { 
            text-align: right; color: #FFE6A6; text-shadow: 0 0 15px rgba(255, 230, 166, 0.5); 
            display: flex; flex-direction: column; align-items: flex-end; gap: 25px; 
            max-width: 240px; background: rgba(20, 15, 10, 0.7); backdrop-filter: blur(8px);
            padding: 25px; border-radius: 20px; border: 1px solid rgba(255, 230, 166, 0.2);
        }
        h1 { margin: 0; font-weight: 300; font-size: 24px; letter-spacing: 2px; }
        .btn-group { pointer-events: auto; display: flex; flex-direction: column; gap: 15px; width: 100%; }
        .btn {
            background: rgba(255, 255, 255, 0.05); color: #FFE6A6; border: 1px solid rgba(255, 230, 166, 0.3);
            padding: 12px 20px; border-radius: 12px; font-size: 13px; cursor: pointer; text-transform: uppercase;
            transition: all 0.4s ease; letter-spacing: 1px; width: 100%; box-sizing: border-box; text-align: center;
        }
        .btn:hover { background: rgba(255, 230, 166, 0.2); color: #fff; box-shadow: 0 0 30px rgba(255, 230, 166, 0.4); border-color: #FFE6A6; }
        .upload-btn { background: rgba(255, 230, 166, 0.15); border-color: #FFE6A6; font-weight: bold; }
        input[type="file"] { display: none; }
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center; color: #FFE6A6; letter-spacing: 4px; font-weight: 300;
        }
        
        .status-badge {
            font-size: 12px; background: rgba(255, 215, 0, 0.2); padding: 5px 10px; border-radius: 15px;
            margin-top: 10px; border: 1px solid rgba(255, 215, 0, 0.5);
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loading"><div>INITIALIZING CAMERA & AI...</div></div>
    
    <div id="canvas-container"></div>
    <div id="hand-cursor"></div>
    
    <video id="input-video"></video>
    <canvas id="camera-preview"></canvas>

    <div id="ui-layer">
        <div class="sidebar-container">
            <h1>Gesture Control</h1>
            <div id="gesture-status" class="status-badge">Waiting for Hand...</div>
            <div class="btn-group">
                <button class="btn upload-btn" onclick="document.getElementById('file-upload').click()">+ Upload Photos</button>
                <input type="file" id="file-upload" multiple accept="image/*">
            </div>
            <div class="btn-group">
                <button class="btn" onclick="window.manualState('TREE')">üéÑ Tree Mode (Fist)</button>
                <button class="btn" onclick="window.manualState('SCATTER')">‚ú® Galaxy Mode (Open)</button>
                <button class="btn" onclick="window.manualState('PHOTO')">üì∏ Grab to View</button>
            </div>
            <div style="font-size: 11px; opacity: 0.7; line-height: 1.5;">
                ‚úä Fist: Tree<br>
                üñê Open: Galaxy<br>
                ü§è Pinch: Grab Photo<br>
                üëã Move: Rotate View
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            particleCount: 15000, 
            colors: [0xFFFFFF, 0xFFE082, 0xFFE082, 0x2E8B57, 0xDC143C], 
        };
        const STATE = { TREE: 'TREE', SCATTER: 'SCATTER', VIEW_PHOTO: 'VIEW_PHOTO' };
        let currentState = STATE.TREE;
        let scene, camera, renderer, controls;
        let photoMeshes = [];
        let starMesh, starData; 
        let trunkGroup; let ribbonMesh; let ribbonPath; 
        let dummy = new THREE.Object3D();
        let particlesData = []; let snowSystem;
        let photoGeometry, iconGeometry;
        
        // Â∞ÑÁ∫øÊ£ÄÊµãÁõ∏ÂÖ≥
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(); // ËøôÈáåÂ∞ÜÂ≠òÂÇ®ÊâãÁöÑÂùêÊ†á
        
        // ÊâãÂäøÁä∂ÊÄÅÊéßÂà∂
        let lastGestureTime = 0;
        const GESTURE_COOLDOWN = 1000; // Áä∂ÊÄÅÂàáÊç¢ÂÜ∑Âç¥Êó∂Èó¥ÔºåÈò≤Ê≠¢Èó™ÁÉÅ

        window.manualState = function(s) { switchState(STATE[s]); };

        function init() {
            initThree();
            initPhotoGeometry(); 
            createThickerTrunk(); 
            createUniformParticles(); 
            createRibbonOnly(); 
            createGlowingStar(); 
            createRefinedEnvironment();
            initEvents(); 
            
            // ÂêØÂä® MediaPipe
            initMediaPipe();
            
            animate();
        }

        // --- MediaPipe Hands Integration ---
        function initMediaPipe() {
            const videoElement = document.getElementById('input-video');
            const previewCanvas = document.getElementById('camera-preview');
            const previewCtx = previewCanvas.getContext('2d');
            const cursor = document.getElementById('hand-cursor');
            const statusDiv = document.getElementById('gesture-status');

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            cameraUtils.start()
                .then(() => {
                    const l = document.getElementById('loading'); 
                    if(l) l.innerHTML = "<div>CAMERA ACTIVE<br>SHOW YOUR HAND</div>";
                    setTimeout(() => l && l.remove(), 1000);
                })
                .catch(err => {
                    alert("Camera access denied or error. Please allow camera for gesture control.");
                    document.getElementById('loading').remove();
                });

            function onResults(results) {
                // ÁªòÂà∂È¢ÑËßàÂ∞èÁ™óÂè£
                previewCtx.save();
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
                if (results.multiHandLandmarks) {
                    for (const landmarks of results.multiHandLandmarks) {
                        drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                        drawLandmarks(previewCtx, landmarks, {color: '#FF0000', lineWidth: 1});
                    }
                }
                previewCtx.restore();

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    processHandLogic(landmarks, cursor, statusDiv);
                } else {
                    cursor.style.display = 'none';
                    statusDiv.innerText = "No Hand Detected";
                    // Ê≤°ÊâãÊó∂ÔºåËá™Âä®ÊóãËΩ¨ÊÅ¢Â§ç
                    if(controls) controls.autoRotate = true;
                }
            }
        }

        function processHandLogic(landmarks, cursor, statusDiv) {
            // 1. ËÆ°ÁÆóÊâãÊéå‰∏≠ÂøÉ (ÁÆÄÂçïÁöÑÁ¥¢Âºï‰∏∫9ÁöÑÊåáÂÖ≥ËäÇ‰Ωú‰∏∫‰∏≠ÂøÉ)
            const palmX = landmarks[9].x; 
            const palmY = landmarks[9].y;

            // MediaPipe ÂùêÊ†áÊòØÂΩí‰∏ÄÂåñÁöÑ 0-1Ôºå‰∏î x ÊòØÈïúÂÉèÁöÑ
            // Â∞ÜÂÖ∂ËΩ¨Êç¢‰∏∫Â±èÂπïÂùêÊ†áÁªôÂÖâÊ†á‰ΩøÁî®
            const screenX = (1 - palmX) * window.innerWidth;
            const screenY = palmY * window.innerHeight;

            cursor.style.display = 'block';
            cursor.style.left = screenX + 'px';
            cursor.style.top = screenY + 'px';

            // Êõ¥Êñ∞Áî®‰∫é Raycaster ÁöÑÂùêÊ†á (-1 Âà∞ 1)
            mouse.x = (1 - palmX) * 2 - 1;
            mouse.y = -(palmY * 2) + 1;

            // 2. ÊâãÂäøËØÜÂà´
            const gesture = detectGestureType(landmarks);
            
            // 3. Ê†πÊçÆÁä∂ÊÄÅÂíåÊâãÂäøÊâßË°åÈÄªËæë
            const now = Date.now();

            if (gesture === 'PINCH') {
                statusDiv.innerText = "ü§è Pinching (Grab)";
                cursor.classList.add('pinching');
                
                // ÊäìÂèñÈÄªËæëÔºöÂ¶ÇÊûúÂÜ∑Âç¥Êó∂Èó¥ËøáÔºå‰∏îÊåáÈíàÂØπÂáÜ‰∫ÜÁÖßÁâá
                if (now - lastGestureTime > GESTURE_COOLDOWN || currentState === STATE.VIEW_PHOTO) {
                    checkRaycastIntersection();
                }
            } else {
                cursor.classList.remove('pinching');
                
                if (gesture === 'FIST') {
                    statusDiv.innerText = "‚úä Fist (To Tree)";
                    if (currentState !== STATE.TREE && now - lastGestureTime > GESTURE_COOLDOWN) {
                        switchState(STATE.TREE);
                        lastGestureTime = now;
                    }
                } else if (gesture === 'OPEN') {
                    statusDiv.innerText = "üñê Open (To Galaxy)";
                    if (currentState !== STATE.SCATTER && now - lastGestureTime > GESTURE_COOLDOWN) {
                        switchState(STATE.SCATTER);
                        lastGestureTime = now;
                    }
                    
                    // üñê ÊâãÂäøÁßªÂä®ÊéßÂà∂Áõ∏Êú∫ (‰ªÖÂú® Scatter Ê®°Âºè‰∏ã)
                    if (currentState === STATE.SCATTER) {
                        handleHandCameraRotation(mouse.x, mouse.y);
                    }
                } else {
                    statusDiv.innerText = "Hand Detected";
                }
            }
        }

        // ÁÆÄÂçïÁöÑÊâãÂäøÂàÜÁ±ªÂô®
        function detectGestureType(landmarks) {
            // ËÆ°ÁÆóÂ§ßÊãáÊåáÂíåÈ£üÊåáË∑ùÁ¶ª (Pinch)
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distance = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
            
            if (distance < 0.05) return 'PINCH';

            // Âà§Êñ≠ÊâãÊåá‰º∏Áõ¥ËøòÊòØÂºØÊõ≤
            // ÁÆÄÂçïÈÄªËæëÔºöÊåáÂ∞ñ(Tip) ÊòØÂê¶Âú® ÊåáÂÖ≥ËäÇ(PIP - Á¨¨‰∫å‰∏™ÂÖ≥ËäÇ) ÁöÑ‰∏äÊñπ (yÂùêÊ†áÊõ¥Â∞è)
            // Ê≥®ÊÑèÔºöËøôÂú®ÊâãÊéåÂûÇÁõ¥Êó∂ÊúâÊïàÔºåÁÆÄÂçïËµ∑ËßÅÊàë‰ª¨ÁªüËÆ°‰º∏Áõ¥ÁöÑÊâãÊåáÊï∞Èáè
            let extendedFingers = 0;
            const tips = [8, 12, 16, 20]; // È£üÊåá„ÄÅ‰∏≠Êåá„ÄÅÊó†ÂêçÊåá„ÄÅÂ∞èÊåá
            const pips = [6, 10, 14, 18]; // ÂØπÂ∫îÁöÑËøëÁ´ØÊåáÂÖ≥ËäÇ

            // ËøôÊòØ‰∏Ä‰∏™ÁÆÄÂåñÁöÑÂà§Êñ≠ÔºåÂÅáËÆæÊâãÊéå‰∏ªË¶ÅÊúù‰∏äÊàñÊúùÂâç
            // Êõ¥‰∏•Ë∞®ÁöÑÊñπÊ≥ïÈúÄË¶ÅËÆ°ÁÆóÂêëÈáèËßíÂ∫¶Ôºå‰ΩÜÂØπ‰∫é web ÊºîÁ§∫Ë∂≥Â§ü‰∫Ü
            // ÊØîËæÉÊåáÂ∞ñÂíåÊâãËÖï(0)ÁöÑË∑ùÁ¶ª vs ÊåáÂÖ≥ËäÇÂíåÊâãËÖïÁöÑË∑ùÁ¶ª
            const wrist = landmarks[0];
            
            tips.forEach((tipIdx, i) => {
                const pipIdx = pips[i];
                const tipDist = Math.sqrt(Math.pow(landmarks[tipIdx].x - wrist.x, 2) + Math.pow(landmarks[tipIdx].y - wrist.y, 2));
                const pipDist = Math.sqrt(Math.pow(landmarks[pipIdx].x - wrist.x, 2) + Math.pow(landmarks[pipIdx].y - wrist.y, 2));
                if (tipDist > pipDist * 1.1) extendedFingers++; // Â¶ÇÊûúÊåáÂ∞ñÊØîÂÖ≥ËäÇÁ¶ªÊâãËÖïËøúÔºåÁÆó‰º∏Áõ¥
            });

            if (extendedFingers >= 3) return 'OPEN';
            if (extendedFingers <= 1) return 'FIST'; // ÂÖÅËÆ∏Â§ßÊãáÊåáÈöèÊÑè
            
            return 'UNKNOWN';
        }

        // ÊâãÂäøÊóãËΩ¨Áõ∏Êú∫ÈÄªËæë
        function handleHandCameraRotation(ndcX, ndcY) {
            if (!controls) return;
            controls.autoRotate = false; // ÊâãÂäøÊéßÂà∂Êó∂ÂÅúÊ≠¢Ëá™Âä®ÊóãËΩ¨
            
            // Â∞ÜÊâãÁöÑ‰ΩçÁΩÆÊò†Â∞ÑÂà∞ÊóãËΩ¨ÈÄüÂ∫¶
            // ‰∏≠ÂøÉÊ≠ªÂå∫ÔºöÊâãÂú®Â±èÂπï‰∏≠Èó¥Êó∂‰∏çÊóãËΩ¨
            const deadZone = 0.2;
            if (Math.abs(ndcX) > deadZone) {
                // Â∑¶Âè≥ÁßªÂä®ÊéßÂà∂Ê∞¥Âπ≥ÊóãËΩ¨ (Azimuth)
                const speed = (ndcX - (ndcX > 0 ? deadZone : -deadZone)) * 2.0;
                // Áõ¥Êé•‰øÆÊîπ OrbitControls ÁöÑËßíÂ∫¶
                // Ê≥®ÊÑèÔºöOrbitControls update ‰ºöË¶ÜÁõñËøô‰∏™ÔºåÊâÄ‰ª•Êàë‰ª¨ÈÄöËøáÊ®°Êãü autoRotate ÊïàÊûúÊàñËÄÖÁõ¥Êé•ÂæÆË∞É‰ΩçÁΩÆ
                // ËøôÈáåÊàë‰ª¨ÈÄâÊã©ÂæÆË∞ÉÁõ∏Êú∫‰ΩçÁΩÆÔºåËÆ© controls.update() Â§ÑÁêÜÂπ≥Êªë
                const offset = speed * 0.05;
                const x = camera.position.x;
                const z = camera.position.z;
                camera.position.x = x * Math.cos(offset) - z * Math.sin(offset);
                camera.position.z = x * Math.sin(offset) + z * Math.cos(offset);
            }
            
            if (Math.abs(ndcY) > deadZone) {
                // ‰∏ä‰∏ãÁßªÂä®ÊéßÂà∂ÂûÇÁõ¥ÊóãËΩ¨ (Polar) - ÈôêÂà∂ËåÉÂõ¥
                const speed = (ndcY - (ndcY > 0 ? deadZone : -deadZone)) * 0.05;
                // ËøôÈáåÁöÑÂ§ÑÁêÜÊØîËæÉ trickÔºåÁõ¥Êé•Êîπ controls Â±ûÊÄßÈÄöÂ∏∏Êõ¥Â•Ω
                // ‰ΩÜÁÆÄÂçïËµ∑ËßÅÔºåÊàë‰ª¨Âè™ÂÅöÊ∞¥Âπ≥ÊóãËΩ¨ÔºåÂûÇÁõ¥ÊóãËΩ¨ÂÆπÊòìÊôï
            }
            
            camera.lookAt(scene.position);
        }

        // Â∞ÑÁ∫øÊ£ÄÊµãÊäìÂèñÁÖßÁâá
        function checkRaycastIntersection() {
            if (photoMeshes.length === 0) return;

            raycaster.setFromCamera(mouse, camera);
            
            // Ê£ÄÊµãÊòØÂê¶Á¢∞Âà∞ÁÖßÁâáÔºàÊ≥®ÊÑèÔºöphotoMesh Áé∞Âú®ÊòØÂåÖÂê´ËæπÊ°ÜÂíåÂõæÊ†áÁöÑ GroupÔºå‰ΩÜ Raycaster ‰πüËÉΩÊ£ÄÊµãÂÖ∂Â≠ê MeshÔºâ
            const intersects = raycaster.intersectObjects(photoMeshes, true); // true Ë°®Á§∫ÈÄíÂΩíÊ£ÄÊµãÂ≠êÂØπË±°

            if (intersects.length > 0) {
                // ÊâæÂà∞‰∫ÜÊúÄËøëÁöÑÁâ©‰Ωì
                let targetObject = intersects[0].object;
                
                // Âêë‰∏äÊü•ÊâæÊâæÂà∞ÊúÄÈ°∂Â±ÇÁöÑ Group (Êàë‰ª¨Â≠òÂÖ• photoMeshes ÁöÑÂØπË±°)
                while(targetObject.parent && targetObject.parent.type !== 'Scene') {
                    if (photoMeshes.includes(targetObject)) break;
                    // Â¶ÇÊûúÊâæÂà∞‰∫ÜÊòØÂõæÊ†áÊàñËÄÖËæπÊ°ÜÔºåÁªßÁª≠ÂæÄ‰∏äÊâæ
                    if (photoMeshes.includes(targetObject.parent)) {
                        targetObject = targetObject.parent;
                        break;
                    }
                    targetObject = targetObject.parent;
                }

                if (photoMeshes.includes(targetObject)) {
                    // Âè™ÊúâÂΩìÊäìÂèñÁöÑÊòØËøòÊ≤°Êü•ÁúãÁöÑÁÖßÁâáÔºåÊàñËÄÖÂú® Tree/Scatter Ê®°Âºè‰∏ãÊâçËß¶Âèë
                    if (currentState !== STATE.VIEW_PHOTO) {
                        enterViewPhotoMode(targetObject);
                    }
                }
            }
        }

        function enterViewPhotoMode(targetMesh) {
            currentState = STATE.VIEW_PHOTO;
            lastGestureTime = Date.now(); // ÈáçÁΩÆÂÜ∑Âç¥
            controls.autoRotate = false;

            // ÊâæÂà∞ÂØπÂ∫îÁöÑÊï∞ÊçÆÂØπË±°
            const p = particlesData.find(x => x.mesh === targetMesh);
            if (!p) return;

            // È£ûÂà∞Áõ∏Êú∫Èù¢Ââç
            const v = new THREE.Vector3(0, 0, -22).applyMatrix4(camera.matrixWorld);
            gsap.to(p.currentPos, { x: v.x, y: v.y, z: v.z, duration: 1.5, ease: "power2.out" });
            gsap.to(p.mesh.scale, { x: 2.0, y: 2.0, z: 2.0, duration: 1.5 }); // ÊîæÂ§ß‰∏ÄÁÇπ
            
            // ËÆ©ÁÖßÁâáÈù¢ÂêëÁõ∏Êú∫
            gsap.to({}, { duration: 1.5, onUpdate: () => {
                p.mesh.lookAt(camera.position);
            }});
        }

        // --- Three.js Logic (Kept mostly same as before) ---

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            const pureBlack = new THREE.Color(0x000000); 
            scene.background = pureBlack;
            scene.fog = new THREE.FogExp2(pureBlack, 0.002); 
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 65);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(pureBlack, 1);
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xFFE6A6, 1.2, 200); pointLight.position.set(20, 50, 50); scene.add(pointLight);
            const bottomLight = new THREE.PointLight(0xA0522D, 0.8, 150); bottomLight.position.set(0, -50, 30); scene.add(bottomLight);

            if (THREE.OrbitControls) {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; controls.autoRotate = true; controls.autoRotateSpeed = 0.5;
                controls.enableZoom = true; controls.maxPolarAngle = Math.PI / 2 + 0.1;
            }
        }

        function optimizeTextureForSharpness(texture) {
            const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
            texture.anisotropy = maxAnisotropy;
            texture.magFilter = THREE.LinearFilter;
            texture.minFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            texture.needsUpdate = true;
        }

        function getContrastColor(imageOrCanvas) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64; canvas.height = 64;
            ctx.drawImage(imageOrCanvas, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            let r = 0, g = 0, b = 0, count = 0;
            for (let i = 0; i < imageData.length; i += 4) {
                r += imageData[i]; g += imageData[i + 1]; b += imageData[i + 2]; count++;
            }
            r = (r / count) / 255; g = (g / count) / 255; b = (b / count) / 255;
            
            const color = new THREE.Color(r, g, b);
            const hsl = {};
            color.getHSL(hsl);
            let contrastHue = (hsl.h + 0.5) % 1.0;
            const contrastColor = new THREE.Color().setHSL(contrastHue, 0.9, 0.75);
            return contrastColor;
        }

        function createIconTexture(type) {
            const size = 128;
            const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = '100px serif';
            
            let iconStr = '';
            const typeIndex = type % 5;
            if (typeIndex === 0) iconStr = 'üîî'; 
            else if (typeIndex === 1) iconStr = 'ü¶å'; 
            else if (typeIndex === 2) iconStr = 'üéÖ'; 
            else if (typeIndex === 3) iconStr = 'üéÅ'; 
            else iconStr = 'üß¶'; 

            ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 20;
            ctx.fillText(iconStr, size / 2, size / 2);

            const tex = new THREE.CanvasTexture(canvas);
            tex.needsUpdate = true;
            return tex;
        }

        function createThickerTrunk() {
            trunkGroup = new THREE.Group();
            const barkMat = new THREE.MeshStandardMaterial({
                color: 0xF0E0D0, roughness: 0.9, metalness: 0.0, flatShading: true
            });
            const stemGeo = new THREE.CylinderGeometry(0.5, 2.0, 65, 24);
            const stemMesh = new THREE.Mesh(stemGeo, barkMat);
            stemMesh.position.y = -7.5; 
            trunkGroup.add(stemMesh);
            scene.add(trunkGroup);
        }

        function createBlurryEdgeTexture() {
            const size = 256; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 0, size);
            gradient.addColorStop(0, 'rgba(0,0,0,0)'); gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.8, 'rgba(255,255,255,1)'); gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient; ctx.fillRect(0, 0, size, size);
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function initPhotoGeometry() {
            photoGeometry = new THREE.PlaneGeometry(6.4, 7.6);
            photoGeometry.translate(0, -2.9, 0);
            iconGeometry = new THREE.PlaneGeometry(2.8, 2.8);
        }

        function createCustomBorderMaterial(texture, borderColor) {
            return new THREE.ShaderMaterial({
                uniforms: {
                    uTexture: { value: texture },
                    uBorderColor: { value: borderColor }, 
                    uPhotoScale: { value: new THREE.Vector2(0.75, 0.76) },
                    uBorderSoftness: { value: 0.15 } 
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D uTexture;
                    uniform vec3 uBorderColor;
                    uniform vec2 uPhotoScale;
                    uniform float uBorderSoftness;
                    varying vec2 vUv;

                    float sdBox(in vec2 p, in vec2 b) {
                        vec2 d = abs(p) - b;
                        return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
                    }

                    void main() {
                        vec2 centeredUv = vUv * 2.0 - 1.0;
                        float dist = sdBox(centeredUv, uPhotoScale);
                        float photoMask = 1.0 - smoothstep(0.0, 0.01, dist);
                        vec2 photoUv = (centeredUv / uPhotoScale) * 0.5 + 0.5;
                        vec4 photoColor = texture2D(uTexture, photoUv);
                        float borderMask = smoothstep(uBorderSoftness, 0.0, dist);
                        vec3 finalColor = mix(uBorderColor, photoColor.rgb, photoMask);
                        gl_FragColor = vec4(finalColor, borderMask);
                    }
                `,
                transparent: true, side: THREE.DoubleSide, depthWrite: false
            });
        }

        function createRibbonOnly() {
            const points = [];
            const turns = 3.5; const heightSpan = 47; const startY = 25; const steps = 300;
            for ( let i = 0; i <= steps; i ++ ) {
                const t = i / steps; const angle = t * Math.PI * 2 * turns;
                const radius = 0.5 + t * 24 + Math.sin(t*Math.PI*5)*1.5; 
                points.push( new THREE.Vector3( Math.cos( angle ) * radius, startY - t * heightSpan, Math.sin( angle ) * radius ) );
            }
            ribbonPath = new THREE.CatmullRomCurve3( points );
            const tubeGeo = new THREE.TubeGeometry( ribbonPath, 400, 0.25, 12, false ); 
            const blurTexture = createBlurryEdgeTexture();
            const ribbonMat = new THREE.MeshStandardMaterial({
                color: 0xFFE6A6, metalness: 0.1, roughness: 0.6, emissive: 0xFFE6A6, emissiveIntensity: 0.4,
                transparent: true, opacity: 0.85, alphaMap: blurTexture, side: THREE.DoubleSide, depthWrite: false
            });
            ribbonMesh = new THREE.Mesh( tubeGeo, ribbonMat );
            scene.add( ribbonMesh );
        }

        function createPhotoMeshesFromTextures(textureDataArray) {
            const count = textureDataArray.length;
            if (count === 0) return;

            const baseCount = 8;
            const minScale = 0.6; 
            let scaleFactor = 1.0;
            if (count > baseCount) {
                scaleFactor = Math.max(minScale, 1.0 - (count - baseCount) * 0.025);
            }

            textureDataArray.forEach((data, i) => {
                const mat = createCustomBorderMaterial(data.tex, data.color);
                const mesh = new THREE.Mesh(photoGeometry, mat);
                
                mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);

                const iconType = i; 
                const iconTex = createIconTexture(iconType);
                const iconMat = new THREE.MeshBasicMaterial({ map: iconTex, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                const iconMesh = new THREE.Mesh(iconGeometry, iconMat);
                
                // Position and RenderOrder
                iconMesh.position.set(0, 0.7, 0.2); 
                iconMesh.renderOrder = 10; 
                
                mesh.add(iconMesh); 

                let t; if (count === 1) { t = 0.5; } else { t = 0.1 + (i / (count - 1)) * 0.8; }
                const treePos = ribbonPath.getPointAt(t);
                const scatterPos = new THREE.Vector3((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*50 + 20);
                
                particlesData.push({ isPhoto: true, mesh: mesh, photoMat: mat, currentPos: treePos.clone(), treePos: treePos, scatterPos: scatterPos });
                mesh.position.copy(treePos); 
                scene.add(mesh); 
                photoMeshes.push(mesh);
            });
        }

        function clearExistingPhotos() {
            for (let i = particlesData.length - 1; i >= 0; i--) {
                if (particlesData[i].isPhoto) {
                    const p = particlesData[i];
                    p.mesh.clear(); 
                    scene.remove(p.mesh);
                    if (p.photoMat.uniforms.uTexture.value) p.photoMat.uniforms.uTexture.value.dispose();
                    p.photoMat.dispose();
                    particlesData.splice(i, 1);
                }
            }
            photoMeshes = [];
        }

        function createRefinedEnvironment() {
            const snowGeo = new THREE.BufferGeometry();
            const snowCount = 300; const snowPos = new Float32Array(snowCount * 3); const snowVel = [];
            for(let i=0; i<snowCount; i++) {
                snowPos[i*3] = (Math.random()-0.5) * 180; snowPos[i*3+1] = Math.random() * 120 - 60; snowPos[i*3+2] = (Math.random()-0.5) * 180; 
                snowVel.push({ y: -0.03 - Math.random() * 0.05 });
            }
            snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
            const snowMat = new THREE.PointsMaterial({ color: 0xFFE6A6, size: 0.4, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, depthWrite: false });
            snowSystem = new THREE.Points(snowGeo, snowMat); snowSystem.userData.velocities = snowVel; scene.add(snowSystem);
        }

        function createGlowingStar() {
            const shape = new THREE.Shape(); const points = 5; const outerRadius = 2.2; const innerRadius = 1.1; 
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points; const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = Math.cos(angle) * radius; const y = Math.sin(angle) * radius; if (i === 0) shape.moveTo(x, y); else shape.lineTo(x, y);
            } shape.closePath();
            const extrudeSettings = { steps: 1, depth: 0.6, bevelEnabled: true, bevelThickness: 0.15, bevelSize: 0.15, bevelSegments: 2 };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings); geometry.center(); 
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700, metalness: 0.8, roughness: 0.2, 
                emissive: 0xFFD700, emissiveIntensity: 5.0 
            });
            starMesh = new THREE.Mesh(geometry, material);
            const treePos = new THREE.Vector3(0, 26, 0); const scatterPos = new THREE.Vector3(0, 85, 0);
            starData = { currentPos: treePos.clone(), treePos: treePos, scatterPos: scatterPos };
            starMesh.position.copy(treePos); starMesh.rotation.z = Math.PI / 10; scene.add(starMesh);
        }

        function createUniformParticles() {
            const geometry = new THREE.SphereGeometry(0.12, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, transparent: true, opacity: 1.0, 
                blending: THREE.AdditiveBlending, depthWrite: false 
            });
            instancesMesh = new THREE.InstancedMesh(geometry, material, CONFIG.particleCount);
            const colorHelper = new THREE.Color();
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const h = 48; const y = (i / CONFIG.particleCount) * h - h/2; const progress = (y + h/2) / h; 
                const baseRadius = (1 - progress) * 17; const rOffset = 0.6 + Math.random() * 0.7; 
                const radius = baseRadius * rOffset; const angle = i * 0.25 + Math.random() * 0.3; 
                const treePos = new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
                const scatterPos = new THREE.Vector3((Math.random()-0.5) * 100, (Math.random()-0.5) * 100, (Math.random()-0.5) * 80);
                colorHelper.setHex(CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]);
                instancesMesh.setColorAt(i, colorHelper);
                particlesData.push({ currentPos: treePos.clone(), treePos: treePos, scatterPos: scatterPos, scale: Math.random() * 0.6 + 0.4, blinkSpeed: Math.random() * 2 + 1, blinkPhase: Math.random() * Math.PI });
                dummy.position.copy(treePos); dummy.updateMatrix(); instancesMesh.setMatrixAt(i, dummy.matrix);
            }
            instancesMesh.instanceMatrix.needsUpdate = true; instancesMesh.instanceColor.needsUpdate = true; scene.add(instancesMesh);
        }

        function initEvents() {
            document.getElementById('file-upload').addEventListener('change', function(e) {
                const files = e.target.files;
                if (files.length === 0) return;
                clearExistingPhotos();
                
                const loadedData = [];
                let loadedCount = 0;
                Array.from(files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const img = new Image();
                        img.onload = () => {
                            const tex = new THREE.Texture(img);
                            optimizeTextureForSharpness(tex);
                            tex.needsUpdate = true;
                            const contrastColor = getContrastColor(img);
                            loadedData[index] = { tex: tex, color: contrastColor };
                            loadedCount++;
                            if (loadedCount === files.length) {
                                createPhotoMeshesFromTextures(loadedData);
                                alert(files.length + " Memories Uploaded! Switching to Galaxy Mode.");
                                switchState(STATE.SCATTER);
                            }
                        };
                        img.src = evt.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            });
            window.addEventListener('resize', function() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        }

        function switchState(newState) {
            if (currentState === newState) return; currentState = newState;
            particlesData.forEach(function(p) {
                const target = (newState === STATE.TREE) ? p.treePos : p.scatterPos; const duration = (newState === STATE.TREE) ? 2.0 : 2.8; const ease = (newState === STATE.TREE) ? "elastic.out(0.6, 0.4)" : "power2.inOut"; 
                gsap.to(p.currentPos, { x: target.x, y: target.y, z: target.z, duration: duration, ease: ease });
                if(p.isPhoto) gsap.to(p.mesh.scale, { x: 1, y: 1, z: 1, duration: 1 });
            });
            if(starMesh && starData) { const target = (newState === STATE.TREE) ? starData.treePos : starData.scatterPos; gsap.to(starData.currentPos, { x: target.x, y: target.y, z: target.z, duration: 2.2, ease: "power2.inOut" }); }
            
            if(trunkGroup) {
                const targetY = (newState === STATE.TREE) ? 0 : -100; 
                gsap.to(trunkGroup.position, { y: targetY, duration: 2.0, ease: "power2.inOut" });
            }
            if(ribbonMesh) {
                 const targetScale = (newState === STATE.TREE) ? 1 : 0;
                 gsap.to(ribbonMesh.scale, { x: targetScale, y: targetScale, z: targetScale, duration: 1.5, ease: "power2.inOut" });
            }

            if (newState === STATE.VIEW_PHOTO) {
                // ... (Logic handled by raycast interaction)
            } else { if(controls) controls.autoRotate = true; }
        }

        function updateScene(time) {
            let dirty = false;
            if(snowSystem) {
                const positions = snowSystem.geometry.attributes.position.array; const vels = snowSystem.userData.velocities;
                for(let i=0; i<vels.length; i++) { positions[i*3+1] += vels[i].y; if(positions[i*3+1] < -60) positions[i*3+1] = 60; }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            if(starMesh && starData) { if (currentState === STATE.SCATTER) starData.currentPos.y += Math.sin(time) * 0.03; starMesh.position.copy(starData.currentPos); starMesh.rotation.y = time * 0.5; }
            particlesData.forEach(function(p, i) {
                if (currentState === STATE.SCATTER) p.currentPos.y += Math.sin(time + i) * 0.01;
                if (p.isPhoto) {
                    p.mesh.position.copy(p.currentPos);
                    if (currentState === STATE.TREE) { 
                        p.mesh.lookAt(camera.position); 
                    } else p.mesh.lookAt(camera.position);
                } else {
                    dummy.position.copy(p.currentPos);
                    const blink = 0.8 + Math.sin(time * p.blinkSpeed + p.blinkPhase) * 0.4;
                    dummy.scale.setScalar(p.scale * blink);
                    dummy.updateMatrix(); instancesMesh.setMatrixAt(i, dummy.matrix); dirty = true;
                }
            });
            if (dirty) instancesMesh.instanceMatrix.needsUpdate = true;
        }

        function animate() { requestAnimationFrame(animate); if (controls) controls.update(); updateScene(performance.now() * 0.001); renderer.render(scene, camera); }
        
        // Start Everything
        init();
        
        window.addEventListener('resize', function() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>